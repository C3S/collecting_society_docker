#!/usr/bin/env python3
# For copyright and license terms, see COPYRIGHT.rst (top level of repository)
# Repository: https://github.com/C3S/collecting_society_docker
"""
Usage: ./scripts/update [--reset] [--diff] [--help]

  This script updates the project:
    - Creation of files and folders
    - Copy of FILE.example files to FILE
    - Checkout/Pull of the source repositories (including this one)
    - Checkout/Pull of the reference repositories

Options:
  --reset: overrides the configuration files with .example
  --diff: just outputs the diff of .example files, performs no other updates
"""

import os
import sys
import shutil
import traceback
import subprocess
import pprint
from subprocess import STDOUT as stdout
from pathlib import Path
import difflib
import re
import yaml
from collections.abc import Mapping
from collections import OrderedDict
from copy import deepcopy

# regex
envre = re.compile(r'''^([^\s=]+)=(?:[\s"']*)(.+?)(?:[\s"']*)$''')
envsubre = re.compile(r'\$\{([A-Z-_]*)\}')

# flags
_command = None      # the initially invoked command
_verbose = False
_debug = False
_reset = False
_commit_msg = False
_self_updated = False
_script_updated = False
_dockerfile_updated = False
_examplefiles_updated = False

# lists
_contexts = []       # list of contexts
_messages = []       # list of messages added
_tasks = []          # list of tasks performed
_actions = []        # list of valid action names, autofilled
_commands = []       # list of valid command names, autofilled


# --- tools -------------------------------------------------------------------

def get_root_dir():
    """Returns the root directory of the project."""
    root = os.path.realpath(
        os.path.join(os.path.abspath(__file__), "..", ".."))
    assert os.path.exists(os.path.join(root, '.git'))
    return root


def get_repo_name(path="."):
    """Returns the repository name of the project."""
    return os.path.basename(os.path.abspath(path))


def get_repo_branch(path="."):
    return subprocess.check_output(
        ('git', 'rev-parse', '--abbrev-ref', 'HEAD'),
        stderr=subprocess.STDOUT).rstrip().decode('utf-8')


def replace_env_vars(dictionary, env):
    """Substitues placeholders in dictionary with environment variables."""
    for key, val in dictionary.items():
        if isinstance(val, Mapping):
            replace_env_vars(val, env)
        elif isinstance(val, list):
            for i, item in enumerate(val):
                if isinstance(item, str):
                    for (match) in envsubre.findall(item):
                        dictionary[key][i] = dictionary[key][i].replace(
                            '${%s}' % match, env[match])
                    continue
                replace_env_vars(item, env)
        elif isinstance(val, str):
            for (match) in envsubre.findall(val):
                dictionary[key] = dictionary[key].replace(
                    '${%s}' % match, env[match])
    return dictionary


def get_dot_env(path="."):
    """Reads the shared environment file and parses it into a dictionary."""
    path = os.path.join(path, ".env")
    if not os.path.isfile(path):
        path += '.example'
    assert os.path.isfile(path)
    env = {}
    with open(path) as _file:
        for line in _file:
            match = envre.match(line)
            if match is not None:
                env[match.group(1)] = match.group(2)
    return replace_env_vars(env, env)


def get_project_yaml(path=".", env={}):
    """Reads the project yaml file and parses it into a dictionary."""
    with open(os.path.join(path, "project.yml"), 'r') as _file:

        # load yaml file
        project = yaml.safe_load(_file)
        replace_env_vars(project, env)

        # inherit configurations
        project['staging'] = merge_dicts(
            deepcopy(project['production']), project['staging'])
        project['testing'] = merge_dicts(
            deepcopy(project['staging']), project['testing'])
        project['development'] = merge_dicts(
            deepcopy(project['testing']), project['development'])

        # preprocess tasks
        for _e, environment in project.items():
            if not environment:
                continue

            # action groups
            groups = environment.get('actions', {})
            for _g, group in groups.items():
                if not isinstance(group, list):
                    continue
                # valid actions
                for action in group:
                    assert action in _actions, (
                        "action `%s` in group `%s` not found.\n\n"
                        "yaml: %s/actions/%s\n"
                        "group: %s" % (action, _g, _e, action, group)
                    )
                continue

            # command tasks
            for _c, project_tasks in environment.get('tasks', {}).items():
                if not project_tasks:
                    continue

                # render batch tasks to tasks
                batch_groups = {}
                batch_tasks = []
                for project_task in project_tasks:
                    batch = project_task.get('batch')
                    if not batch:
                        batch_tasks.append({
                            **project_task,
                            **{'batch_group': False}
                        })
                    else:
                        batch_group = project_task['name']
                        assert batch_group not in batch_groups
                        batch_groups[batch_group] = project_task
                        for batch_task in project_task['batch']:
                            batch_tasks.append({
                                **project_task,
                                **{'name': False},  # ensure name check works
                                **batch_task,
                                **{'batch_group': batch_group}
                            })

                # substitue task groups
                for batch_task in batch_tasks:
                    actions = []
                    for action in batch_task.get('actions'):
                        is_group = isinstance(groups.get(action), list)
                        if is_group and action in groups:
                            actions += groups[action]
                            continue
                        actions.append(action)
                    batch_task['actions'] = actions

                # render actions to tasks
                action_groups = {}
                tasks = []
                for task in batch_tasks:
                    action_group = "%s -> %s" % (
                        task.get('batch_group'), task.get('name'))
                    assert action_group not in action_groups
                    action_groups[action_group] = task
                    for action in task.get('actions', {}):
                        tasks.append({
                            **task,
                            **{'action': action, 'action_group': action_group}
                        })

                # task validation
                for task in tasks:
                    # ensure task name
                    assert task.get('name'), (
                        "task has no name.\n\n"
                        "yaml: %s/tasks/%s\n"
                        "task: %s" % (_e, _c, task)
                    )
                    # ensure task action
                    assert task.get('action'), (
                        "task has no action.\n\n"
                        "yaml: %s/tasks/%s\n"
                        "task: %s" % (_e, _c, task)
                    )
                    # ensure task actions are valid
                    assert task['action'] in _actions, (
                        "action `%s` of task with name `%s` not found.\n\n"
                        "yaml: %s/tasks/%s\n"
                        "task: %s" % (action, task['name'], _e, _c, task)
                    )

                # save environment
                environment['batch_groups'] = batch_groups
                environment['action_groups'] = action_groups
                environment['tasks'][_c] = tasks

    return project


def merge_dicts(orig_dict, new_dict):
    """
    Recursively merges dict-like objects.

    Note:
        If a value in new_dict is `{}`, the key is removed in orig_dict.
        Lists of dicts
        - are merged with key 'name' as identifier.
        - can be inserted with the key 'before'/'after' and value name.

    Args:
        orig_dict (dict): Original dictionary to be merged with.
        new_dict (dict): New dictionary to be merged.

    Returns:
        dict: Merged dict.

    Examples:
        >>> orig_dict = {
        ...     'A': {
        ...         'A1': 'A1',
        ...         'A2': 'A2'
        ...     },
        ...     'B': 'B'
        ...     'C': [
        ...         {'name': 'one', 'item': 'old'},
        ...         {'name': 'three'},
        ...     ]
        ... }
        >>> new_dict = {
        ...     'A': {
        ...         'A2': 'XX'
        ...     },
        ...     'B': {},
        ...     'C': [
        ...         {'name': 'one', 'item': 'new'},
        ...         {'name': 'two', 'after': 'one'},
        ...     'D': 'D'
        ... }
        >>> print(cls.merge_dicts(orig_dict, new_dict))
        {
            'A': {
                'A1': 'A1',
                'A2': 'XX'
            },
            'C': [
                {'name': 'one', 'item': 'new'},
                {'name': 'two'},
                {'name': 'three'},
            ],
            'D': 'D',
        }
    """
    if not new_dict:
        return isinstance(new_dict, Mapping) and new_dict or orig_dict
    for key, val in new_dict.items():
        # delete key if val == {}
        if isinstance(val, Mapping) and not val:
            orig_dict.pop(key, None)
        # update with OrderedDict
        if isinstance(val, OrderedDict):
            r = merge_dicts(OrderedDict(orig_dict.get(key, {})), val)
            orig_dict[key] = r
        # update with Mapping
        elif isinstance(val, Mapping):
            r = merge_dicts(orig_dict.get(key, {}), val)
            orig_dict[key] = r
        # update with Lists of items having all the key 'name'
        elif isinstance(val, list) and \
                sum(['name' in v for v in val]) == len(val):
            for new_item in val:
                new = True
                for i, orig_item in enumerate(orig_dict[key]):
                    if new_item['name'] == orig_item['name']:
                        new = False
                        orig_dict[key][i] = merge_dicts(orig_item, new_item)
                if new:
                    insert = ''
                    if 'after' in new_item:
                        insert = 'after'
                    if 'before' in new_item:
                        insert = 'before'
                    if insert:
                        for i, orig_item in enumerate(orig_dict[key]):
                            if new_item[insert] == orig_item['name']:
                                break
                        if insert == 'after':
                            i += 1
                        new_item.pop('after', None)
                        new_item.pop('before', None)
                        orig_dict[key].insert(i, new_item)
                    else:
                        orig_dict[key].append(new_item)
        # update with other objects
        elif isinstance(orig_dict, Mapping):
            orig_dict[key] = new_dict[key]
        else:
            orig_dict = {key: new_dict[key]}
    return orig_dict


# --- templates ---------------------------------------------------------------

def color(text, status):
    """Colored output wrapper for stdout text."""
    text = str(text)
    if isinstance(status, str):
        status = [status]
    # start
    for s in status:
        s = s.lower()
        if s.startswith("\033"):
            text = s + text
        if s in colors:
            text = color(text, colors[s])
    # stop
    if text.startswith("\033") and not text.endswith("[0m"):
        text += colors['clear']
    return text


def message(msg, offset=1, pad=10, data=True, add=True, output=True):
    """Prints a message."""
    # default
    default = {'level': "debug"}
    if _tasks:
        default['action'] = _tasks[-1]['action'].replace("_", " ")
        default['title'] = _tasks[-1]['name']
    msg = {**default, **msg}
    # color
    _color = msg.get("level", "dim")
    # level
    text = "  " * offset
    level = (msg['level'] + " | ").rjust(pad)
    text += color(level, _color + "_level")
    # title
    if 'title' in msg:
        title = msg['title']
        if title == ".":
            title = repo
        text += color(title, _color + "_title") + " "
    # action
    if 'action' in msg:
        action = msg['action'] + " ... "
        if msg['level'] == "error":
            action = msg['action']
        if 'description' in msg:
            action = msg['action'] + " Â» "
        text += color(action, _color + "_action")
    # description
    if 'description' in msg:
        if msg['level'] == 'error':
            _color = 'info'
        text += color(msg["description"], [_color + "_description", 'italic'])
    # data
    if data and 'data' in msg and msg['data']:
        raw = msg['data']
        if isinstance(raw, (bytes, bytearray)):
            raw = raw.strip().decode('utf-8')
        lines = raw
        if isinstance(raw, str):
            lines = raw.rstrip().split("\n")
        else:
            lines = pprint.pformat(raw).split("\n")
        data = ""
        for line in lines:
            data += "\n" + "  " * offset + " ".ljust(pad) + line
        data += "\n"
        text += color(data, _color + "_data")
    text += "\n"
    # process
    if add:
        _messages.append(msg)
    if output and msg['level'] in levels['output']:
        print(text, end="")
    return text


def line(length=89, _color="title", end="\n", output=True):
    """Prints a division line."""
    text = color("-" * length, _color)
    # process
    if output:
        print(text, end=end)
    return text


def header(output=True):
    """Prints the project configuration header."""
    # data
    data = {
        "project": env.get('PROJECT'),
        "environment": environment,
        "branch": branch,
        "root": root,
    }
    if username and useremail:
        data['user'] = "%s <%s>" % (username, useremail)
    else:
        global_username = execute(
            ('git', 'config', '--global', 'user.name'), log=False)
        global_useremail = execute(
            ('git', 'config', '--global', 'user.name'), log=False)
        data['user'] = "%s <%s>" % (global_username, global_useremail)
        message({'level': "info",
                 'description': "GIT_USER_NAME/EMAIL in .env not set",
                 'data': "NOTE: commits will use: %s" % data['user']})
    # text
    pad = 0
    for key in data:
        if len(key) > pad:
            pad = len(key)
    pad += 1
    text = "\n"
    for key, value in data.items():
        value_color = 'dim'
        if key in ['environment', 'branch'] and value not in environments:
            value_color = 'warning'
        text += (
            color("  " + key.capitalize().ljust(pad), 'title') +
            color(value + "\n", value_color)
        )
    separator = line(output=False)
    text = "\n" + separator + "\n" + text + "\n" + separator + "\n"
    # process
    if output:
        print(text, end="")
    return text


def title(string, _color="subtitle", output=True):
    """Prints a formatted title."""
    text = "\n" + color("> ", 'title') + color(string, _color) + "\n\n"
    # process
    if output:
        print(text, end="")
    return text


def footer(string="Success.", _color="success", output=True, summary=True):
    """Prints the result of the command and a summary of important messages."""
    # determine what to output
    had_output = False
    has_summary = False
    for msg in _messages:
        if msg['level'] in levels['output']:
            had_output = True
        if msg['level'] in levels['summary']:
            has_summary = True
    if not had_output:
        print(color("   All fine.", 'dim'))
    # separator
    text = "\n" + line(output=False) + "\n\n"
    # summary
    text += title("Summary", _color='title', output=False)
    # data
    data = {
        "environment": environment,
        "branch": branch,
    }
    text += "  "
    for key, value in data.items():
        value_color = 'dim'
        if key in ['environment', 'branch'] and value not in environments:
            value_color = 'warning'
        text += (
            color(key.capitalize(), ['dim', 'bold']) + " " +
            color(value, value_color) + ", "
        )
    text = text[:-2] + "\n"
    # messages
    if summary and has_summary:
        text += "\n"
        data = False
        for level in levels['summary']:
            if level == 'ERROR':
                data = True
            for msg in [m for m in _messages if m['level'] == level]:
                text += message(msg, data=data, add=False, output=False)
    # title
    text += title(string, _color=_color, output=False)
    # process
    if output:
        print(text, end="")
    return text


def debug(obj=None, title=""):
    """Prints objects for debugging."""
    if not _debug:
        return
    pad = 12
    # title
    if title:
        print(" " * pad + color(title, ['output', 'bold']))
    # object
    if not isinstance(obj, str):
        obj = pprint.pformat(obj)
    for line in obj.split("\n"):
        print(" " * pad + color(line, 'output'))
    print()


def error(msg):
    """Prints an error."""
    _msg = {
        'level': "error",
    }
    if _tasks:
        _msg['title'] = "%s: `%s`" % (
            _tasks[-1]['action'].replace("_", " "), _tasks[-1]['name'])
    message({**_msg, **msg})
    footer("Aborted.", _color="info", summary=False)
    sys.exit(-1)


# --- execution ---------------------------------------------------------------

def execute(cmd, cwd=False, abort=True, msg={}, log=True,
            stop_batch=False, stop_actions=False):
    """Executes a command via subprocess check_output."""
    # print hint for the operation
    context = get_context()
    task = None
    action = "command"
    title = " ".join(cmd)
    if _tasks:
        task = _tasks[-1]
        action = task['action'].replace("_", " ") or "command"
        title = task['name'] or " ".join(cmd)
    if log:
        message({'action': action, 'title': title}, add=False)
    output = ""
    error_msg = {}

    # execute command
    try:
        output = subprocess.check_output(
            cmd, cwd=cwd or root, stderr=stdout
        ).rstrip().decode('utf-8')
        if _debug:
            debug(output, "$ " + " ".join(cmd))
    except subprocess.CalledProcessError as err:
        error_msg = {
            'title': "$ " + cmd[0],
            'action': len(cmd) > 1 and " ".join(cmd[1:]) or "",
            'data': err.output,
        }
        if abort:
            error(error_msg)

    # stop processing
    if task:
        # stop batch groups
        if stop_batch:
            stopped = output
            if callable(stop_batch):
                stopped = stop_batch(output)
            batch_groups = context['batch_groups']
            batch_group = context['batch_group']
            batch_groups[batch_group]['stopped'] = stopped
        # stop action groups
        if stop_actions:
            stopped = output
            if callable(stop_actions):
                stopped = stop_actions(output)
            action_groups = context['action_groups']
            action_group = context['action_group']
            action_groups[action_group]['stopped'] = stopped

    # return if logging is disabled for this command
    if not log:
        return output

    # create message
    _msg = {
        'level': output and "warning" or "info",
        'action': action,
        'title': title,
        'description': output and "not ok" or "ok",
        # 'data': output and "$ " + " ".join(cmd) + "\n" + output,
        'data': output,
    }
    msg = {**_msg, **msg, **error_msg}

    # execute callback functions for messages dependent on the output
    for key, value in msg.items():
        if callable(value):
            msg[key] = value(output)

    # remove line, add and print message
    if 'debug' in levels['output']:
        sys.stdout.write("\033[F")
    message(msg)

    # add output to task
    if _tasks:
        task = _tasks[-1]
        if 'output' not in task:
            task['output'] = {}
        task['output'][task['action']] = output
    return output


# --- actions -----------------------------------------------------------------

def action(func):
    """Action decorator, registers available functions, skips stopped tasks."""
    current_action = func.__name__
    _actions.append(current_action)

    def wrapper(task, context={}, *args, **kwargs):
        # get last context, if empty
        if not context:
            context = get_context()
        # stop to process actions of stopped tasks batches
        batch_groups = context['batch_groups']
        batch_group = context['batch_group']
        if batch_group:
            batch_stopped = batch_groups[batch_group].get('stopped')
            if batch_stopped:
                return
        # stop to process actions of stopped action groups
        action_groups = context['action_groups']
        action_group = context['action_group']
        if action_group:
            actions_stopped = action_groups[action_group].get('stopped')
            if actions_stopped:
                return
        # add action config
        actions_config = project[environment]['actions']
        context['actions'] = actions_config.get(current_action)
        # apply the action
        try:
            func(task, context, *args, **kwargs)
        except Exception:
            error({'data': traceback.format_exc()})
    return wrapper


@action
def link_path(task, context={}):
    """Symlinks a file or folder."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # source path does not exist
    if not os.path.exists(source):
        error({'description': "source path not found",
               'data': "source: %s" % task['source']})

    # new symlink, file does not exist
    source_rel = os.path.relpath(source, os.path.dirname(target))
    if not os.path.exists(target):
        os.symlink(source_rel, target)
        message({'level': "info", 'description': "symlink created"})
        return

    # file exists, but is no symlink
    if not os.path.islink(target):
        error({'description': "target exists and is not a link"})

    # symlink exists and points already to source
    old_source = os.readlink(target)
    if source_rel == old_source:
        message({'description': "symlink exists"})
        return

    # symlink exists, but is changed
    os.unlink(target)
    os.symlink(source_rel, target)
    message({'level': "warning", 'description': "symlink overwritten",
             'data': "\n".join(["old source: `%s`" % old_source,
                                "new source: `%s`" % source_rel])})


@action
def create_file(task, context={}):
    """Creates a file."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    target = os.path.join(root, target)
    target_folder = os.path.dirname(target)

    # folder of file does not exist
    if not os.path.isdir(target_folder):
        error({'description': "folder does not exist", 'data': target_folder})

    # file already exists
    if os.path.exists(target):
        message({'description': "file exists"})
        return

    # new file created
    Path(target).touch()
    message({'level': "info", 'description': "file created"})


@action
def copy_file(task, context={}):
    """Copies a file."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    source = task.get('source')
    if not source:
        source = target + ".example"
    target = os.path.join(root, target)
    source = os.path.join(root, source)

    # source file to copy not found
    if not os.path.exists(source):
        error({'description': "source file not found"})

    # file already exists
    target_exists = os.path.exists(target)
    if target_exists and not _reset:
        message({'description': "file_exists"})
        return

    # file overwritten due to reset switch
    if target_exists and _reset:
        shutil.copyfile(source, target)
        message({'level': "warning", 'description': "file overwritten"})
        return

    # new file copied
    shutil.copyfile(source, target)
    message({'level': "info", 'description': "file copied"})


@action
def diff_file(task, context={}):
    """Diffs example files, prints output and returns different filenames."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    source = task.get('source')
    if not source:
        source = target + ".example"
    target = os.path.join(root, target)
    source = os.path.join(root, source)

    # source or target not found
    if not os.path.exists(source):
        error({'description': "source path not found"})
    if not os.path.exists(target):
        error({'description': "target path not found"})

    # create diff
    with open(source, 'r') as source_file, open(target, 'r') as target_file:

        # get diff
        source_content = source_file.readlines()
        target_content = target_file.readlines()
        diff = difflib.unified_diff(
            source_content, target_content,
            fromfile=os.path.basename(source), tofile=task["name"])
        try:
            line = next(diff)
        except StopIteration:
            message({'description': 'file is identical'})
            return
        lines = [line] + [d for d in diff]

        # filter diff
        ignorere = context['actions']['ignore']
        if isinstance(ignorere, list):
            ignorere = re.compile(r'(%s)' % "|".join(ignorere))
            context['actions']['ignore'] = ignorere
        ignored = False
        filtered = []
        for line in lines[2:]:
            if not line[0] in ["+", "-"]:
                continue
            match = ignorere.match(line[1:])
            if match is not None:
                ignored = True
                continue
            filtered.append(line)

        # files are identical
        if not filtered:
            message({'level': 'info',
                     'description': 'file contain only ignored differences'})
            return

        # files have differences
        data = colors['clear']
        if ignored:
            data += color("--8<-- (ignored lines stripped) --8<--", "dim")
            data += colors['clear'] + "\n"
        for line in lines[0:3] + filtered:
            if line.startswith('-'):
                data += colors['remove']
            if line.startswith('+'):
                data += colors['add']
            if line.startswith('@'):
                data += colors['hunk']
            data += line
        data = data.rstrip() + colors['clear']
        level = "warning"
        description = "differences found"
        if _examplefiles_updated:
            level = "error"
            description += " (examplefiles changed!)"
        message({'level': level, 'description': description,
                 'data': data})


@action
def create_folder(task, context={}):
    """Creates a folder."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    target = os.path.join(root, target)

    # folder already exists
    if os.path.exists(target):
        message({'description': "folder exists"})
        return

    # new folder created
    os.makedirs(target)
    message({'level': "info", 'description': "folder created"})


@action
def copy_folder(task, context={}):
    """Copies a folder."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # folder already exists
    if os.path.exists(target) and not _reset:
        message({'description': "folder exists"})
        return

    # folder overwritten due to reset switch
    shutil.copytree(source, target)
    if _reset:
        shutil.copytree(source, target)
        message({'level': "info", 'description': "folder copied"})
        return

    # new folder copied
    shutil.copytree(source, target)
    message({'level': "warning", 'description': "folder overwritten"})


@action
def git_clone(task, context={}):
    """Clones a repository."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # create containing path for repo
    if context['actions']['create_folder']:
        create_folder({'name': os.path.dirname(target)})

    # choose ssh or https
    if "@" in source and not (username and useremail):
        url = source.split("@", 1)[1]
        source = "https://" + url.replace(":", "/")

    # repo already exists
    if os.path.exists(os.path.join(target, '.git')):
        message({'description': "repo exists"})
        return

    # new repo cloned
    execute(('git', 'clone', '--quiet', source, target))


@action
def git_origin(task, context={}):
    """Sets the origin of a repository."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # choose ssh or https
    if "@" in source and not (username and useremail):
        url = source.split("@", 1)[1]
        source = "https://" + url.replace(":", "/")

    # origin already set
    old_source = execute(
        ('git', 'remote', 'get-url', 'origin'), cwd=target, log=False)
    if source == old_source:
        message({'description': "origin already set"})
        return

    # origin changed
    msg = {
        'level': "warning",
        'description': "origin changed",
        'data': "\n".join([
            "old origin: `%s`" % old_source,
            "new origin: `%s`" % source])}
    execute(('git', 'remote', 'set-url', 'origin', source),
            cwd=target, msg=msg)


@action
def git_user(task, context={}):
    """Sets the username and useremail of a repository."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)

    # skip silently for upstream repos
    if upstream:
        return

    # skip silently, if userdata is not set
    if not username or not useremail:
        return

    # userdata already set
    old_username = execute(
        ('git', 'config', 'user.name'), cwd=target, log=False).strip('"')
    old_useremail = execute(
        ('git', 'config', 'user.email'), cwd=target, log=False).strip('"')
    if username == old_username and old_useremail == old_useremail:
        message({'description': "git user aready set"})
        return

    # userdata set
    execute(('git', 'config', 'user.name', '"{}"'.format(username)),
            cwd=target, log=False)
    execute(('git', 'config', 'user.email', '"{}"'.format(useremail)),
            cwd=target, log=False)
    message({'level': "info", 'description': "git user set",
             'data': "\n".join(["user.name: `%s`" % username,
                                "user.email: `%s`" % useremail])})


@action
def git_status(task, context={}):
    """Checks the status of the repository, cancels task if not ok."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)

    # workdir checked
    cmd = ['git', 'status']
    if upstream:
        cmd.append('--untracked-files=no')

    # procelain
    if context['actions']['porcelain']:
        msg = {'level': lambda o: o and "warning" or "debug",
               'description':
                   lambda o: o and "workdir dirty -> update skipped" or "ok"}
        cmd.append('--porcelain')
        execute(cmd, cwd=target, stop_actions=True, msg=msg)
        return

    # full
    clean = True
    colored = [colors['clear']]
    output = execute(cmd, cwd=target, stop_actions=True, log=False).split("\n")
    _color = ''
    for line in output:
        if line.startswith("  ("):
            _color = 'remove'
            if 'reset' in line:
                _color = 'add'
        if not line.startswith("\t"):
            colored.append(color(line, 'dim'))
            continue
        clean = False
        colored.append(color(line, _color))
    if clean:
        message({'level': "info", 'data': "\n".join(output)})
        return
    message({'level': "warning", 'data': "\n".join(colored)})


@action
def git_fetch(task, context={}):
    """Fetches updates for a repository."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # new updates fetched
    msg = {'level': lambda o: o and "info" or "debug",
           'description': lambda o: o and "updates available" or "uptodate"}
    execute(('git', 'fetch'), cwd=target, msg=msg)


@action
def git_checkout(task, context={}):
    """Checksout a branch or tag in a repository."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']
    upstream = task.get('upstream', True)

    # get checked out version
    old_version = execute(
        ('git', 'rev-parse', '--abbrev-ref', 'HEAD'), cwd=target, log=False)
    if old_version == "HEAD":
        old_version = execute(
            ('git', 'name-rev', '--name-only', 'HEAD'), cwd=target, log=False)
    if old_version.endswith("^0"):
        old_version = old_version[:-2]
    checked_out = old_version == version and True or False

    # find out, if branch or tag exists locally
    version_exists = False
    if version.startswith("tags/"):
        output = execute(
            ('git', 'tag', '-l', version[5:]), cwd=target, log=False)
        if output:
            version_exists = True
    else:
        output = execute(('git', 'branch', '-lvv'), cwd=target, log=False)
        for line in output.split("\n"):
            if line[2:].startswith(version + " "):
                version_exists = True

    # just checkout, if remote or local branch exists
    if version_exists:

        # version already checked out
        if checked_out:
            message({'description': "already on `%s`" % version})
            return

        # version switched
        msg = {'level': "info", 'description': "branch switched",
               'data': "\n".join(["old branch/tag: `%s`" % old_version,
                                  "new branch/tag: `%s`" % version])}
        execute(('git', 'checkout', '--quiet', version),
                cwd=target, msg=msg)
        return

    # upstream version does not exist
    if upstream or version.startswith("tags/"):
        error({'description': "no upstream version `%s` found" % version})

    # new branch created
    msg = {'level': 'info', 'description': "new branch created",
           'data': 'branch name: `%s`' % version}
    execute(('git', 'checkout', '-b', version), cwd=target, msg=msg)


@action
def git_track(task, context={}):
    """Ensures, that remote branches are followed."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']
    upstream = task.get('upstream', True)

    # skip silently for upstream repos and tags
    if upstream or version.startswith("tags/"):
        return

    # find out, if remote branch exists
    remote_exists = False
    output = execute(('git', 'branch', '-rvv'), cwd=target, log=False)
    for line in output.split("\n"):
        if line[2:].startswith("origin/%s " % version):
            remote_exists = True

    # skip, if remote brach does not exist
    if not remote_exists:
        message({'description':
                 'upstream branch `%s` does not exist' % version})
        return

    # get currently tracked branch
    tracked_branch = execute(
        ('git', 'rev-parse', '--abbrev-ref',
         '--symbolic-full-name', '@{u}'),
        cwd=target, abort=False, log=False)
    is_tracked = tracked_branch == "origin/%s" % version

    # remote branch is already tracked
    if is_tracked:
        message({'description':
                 'upstream branch `%s` already tracked' % version})
        return

    # track remote branch
    # NOTE: conflicts, if the same branch was created and committed to on
    # different repositories. this edge case should be rare.
    msg = {'level': "info",
           'description':
               "switched upstream branch from `%s` to `%s`" % (
                   tracked_branch, "origin/%s" % version)}
    execute(('git', 'branch', '-u', 'origin/%s' % version, version),
            cwd=target, msg=msg)


@action
def git_pull(task, context={}):
    """Pulls updates in a repository branch."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']

    # skip pull silently for tags
    if task['version'].startswith("tags/"):
        return

    # skip pull for local only branches
    tracked_branch = execute(
        ('git', 'rev-parse', '--abbrev-ref',
         '--symbolic-full-name', '@{u}'),
        cwd=target, abort=False, log=False)
    is_local = not tracked_branch.startswith("origin/%s" % version)
    if is_local:
        message({'description': "no remote branch `%s` -> pull skipped"
                 % version})
        return

    # pull performed
    msg = {'level': lambda o: 'changed' in o and "info" or "debug",
           'description': lambda o: 'changed' in o and "updated" or "uptodate",
           'data': lambda o: 'changed' in o and o or ""}
    execute(('git', 'pull'), cwd=target, msg=msg)


@action
def git_commit(task, context={}):
    """Commits all changed and untracked files."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)
    if not _commit_msg:
        error({'description': "no commit message"})

    # skip silently for upstream repos
    if upstream:
        return

    # skip repos with clean workdir
    output = execute(('git', 'status', '--porcelain'), cwd=target, log=False)
    if not output:
        message({'description': "nothing to commit"})
        return

    # add performed
    msg = {'level': "info", 'description': "changes added", 'data': output}
    execute(('git', 'add', '-A'), cwd=target, msg=msg)

    # commit performed
    msg = {'level': "info", 'description': "changes commited"}
    execute(('git', 'commit', '-m', _commit_msg),
            cwd=target, msg=msg, abort=False)


@action
def git_push(task, context={}):
    """Pushes all staged commits to remote origin."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)
    version = task['version']

    # skip silently for upstream repos
    if upstream:
        return

    # find out, if remote branch exists
    remote_exists = False
    output = execute(('git', 'branch', '-rvv'), cwd=target, log=False)
    for line in output.split("\n"):
        if line[2:].startswith("origin/%s " % version):
            remote_exists = True

    # skip local only branches
    if not remote_exists:
        message({'level': "warning", 'description': "no remote branch"})
        return

    # find out, if unpushed commits exist
    unpushed = execute(('git', 'log', '@{u}..'), cwd=target, log=False)

    # skip repos without commits
    if not unpushed:
        return

    # add performed
    msg = {'level': "info", 'description': "commits pushed", 'data': unpushed}
    execute(('git', 'push'), cwd=target, msg=msg)


@action
def restart_script(task, context={}):
    """Restarts the update script after updated of itself was checkedout."""
    # target = task['name']
    # updated = ['self']
    # if pull_result:
    #     if 'scripts/update |' in pull_result:
    #         updated.append('script')
    #     if 'services/build/Dockerfile |' in pull_result:
    #         updated.append('dockerfile')
    #     if '.example |' in pull_result:
    #         updated.append('examplefiles')
    pass


# --- tasks -------------------------------------------------------------------

def get_context():
    """Returns the current context."""
    if _contexts:
        return _contexts[-1]
    return


def set_context(override={}):
    """Sets the context for a command, adds it to the stack."""
    current_env = project[environment]
    current_cmd = override.get('command', _command)
    # default context
    context = {
        # command config
        'commands': current_env['commands'].get(current_cmd),
        # current command
        'command': current_cmd,
        # batch groups
        'batch_groups': current_env['batch_groups'],
        # current batch group
        'batch_group': None,
        # action groups
        'action_groups': current_env['action_groups'],
        # current action group
        'action_group': None,
        # command tasks
        'tasks': current_env['tasks'].get(current_cmd),
        # current task
        'task': None,
        # action config
        'actions': current_env['actions'],
        # current action
        'action': None,
    }
    # overrides
    context.update(override)
    # add context
    _contexts.append(context)
    return context


def process(context):
    """Main loop to process tasks."""
    # no tasks
    if not context['tasks']:
        error({'title': "No tasks"})
    # process tasks
    for task in context['tasks']:
        action = task['action']
        context['task'] = task
        context['action'] = action
        context['action_group'] = task['action_group']
        context['batch_group'] = task['batch_group']
        _tasks.append(task)
        if action not in _actions:
            error({'description': "action not found",
                   'data': task})
        getattr(sys.modules[__name__], action)(task, context)
    _contexts.pop()


# --- commands ----------------------------------------------------------------

def command(func):
    """Command decorator, handles context and wrap switch."""
    current_command = func.__name__
    _commands.append(current_command)

    def wrapper(*args, **kwargs):
        # set new command context
        context = set_context({'command': _command})
        # apply filters
        try:
            func(*args, **kwargs)
        except Exception:
            error({'data': traceback.format_exc()})
        # print header (only once)
        if current_command == _command:
            header()
        # print title
        title(_command.capitalize() + " ...")
        # process tasks
        process(context)
        # print footer (only once)
        if current_command == _command:
            footer()
    return wrapper


@command
def update():
    """Updates itself and the repositories, creates folders, copies files."""
    pass


@command
def diff():
    """Prints the diffs of the example files."""
    # filter tasks
    context = get_context()
    tasks = []
    for task in context['tasks']:
        if task['action'] != 'diff_file':
            continue
        tasks.append(task)
    context['tasks'] = tasks


@command
def status():
    """Prints the status of the project repositories."""
    # filter tasks
    context = get_context()
    tasks = []
    for task in context['tasks']:
        if task['action'] != 'git_status':
            continue
        if 'upstream' not in task or task['upstream']:
            continue
        tasks.append(task)
    context['tasks'] = tasks
    context['actions']['git_status']['porcelain'] = False


@command
def pull():
    """Pulls only the project repositories."""
    # filter tasks
    context = get_context()
    tasks = []
    for task in context['tasks']:
        if task['action'] != 'git_pull':
            continue
        if 'upstream' not in task or task['upstream']:
            continue
        tasks.append(task)
    context['tasks'] = tasks


@command
def commit():
    """Commits changes and untracked files to the project repositories."""
    # filter tasks
    context = get_context()
    tasks = []
    for task in context['tasks']:
        if task['action'] != 'git_pull':
            continue
        if 'upstream' not in task or task['upstream']:
            continue
        task['action'] = 'git_commit'
        tasks.append(task)
    context['tasks'] = tasks


@command
def push():
    """Pushes commits of the project repositories."""
    # filter tasks
    context = get_context()
    tasks = []
    for task in context['tasks']:
        if task['action'] != 'git_pull':
            continue
        if 'upstream' not in task or task['upstream']:
            continue
        tasks.append({**task, **{'action': 'git_fetch'}})
        tasks.append({**task, **{'action': 'git_pull'}})
        tasks.append({**task, **{'action': 'git_push'}})
    context['tasks'] = tasks


# --- configuration -----------------------------------------------------------

# project
root = get_root_dir()
repo = get_repo_name(root)
env = get_dot_env(root)
project = get_project_yaml(root, env)
environments = project.keys()

# environment
environment = env['ENVIRONMENT']
branch = env['BRANCH']
username = env.get('GIT_USER_NAME')
useremail = env.get('GIT_USER_EMAIL')

# messages
levels = {
    'output':  ['error', 'warning', 'info'],
    'summary': ['error', 'warning']
}
colors = {
    # level
    'error': "\033[91m",
    'error_level': 'error',
    'error_title': ['title', 'bold'],
    'error_action': '',
    'error_description': ['error', 'bold'],
    'error_data': 'dim',
    'warning': "\033[33m",
    'warning_level': 'warning',
    'warning_title': ['warning', 'bold'],
    'warning_action': '',
    'warning_description': 'warning',
    'warning_data': 'dim',
    'info': '',
    'info_level': 'info',
    'info_title': ['info', 'bold'],
    'info_action': 'info',
    'info_description': 'dim',
    'info_data': 'dim',
    'debug': "\033[2m",
    'debug_level': 'debug',
    'debug_title': ['debug', 'bold'],
    'debug_action': 'dim',
    'debug_description': 'debug',
    'debug_data': 'dim',
    # context
    'title': ['bold', "\033[33m"],
    'subtitle': "\033[35m",
    'output': "\033[94m",
    'success': "\033[32m",
    # diff
    'hunk': "\033[36m",
    'remove': "\033[31m",
    'add': "\033[32m",
    # function
    'clear': "\033[0m",
    'bold': "\033[1m",
    'dim': "\033[2m",
    'italic': "\033[3m",
    'underline': "\033[4m",
    'blink': "\033[5m",
}


# --- entrypoint --------------------------------------------------------------

if __name__ == "__main__":

    # set flags
    if "--reset" in sys.argv:
        _reset = True
    if "--verbose" in sys.argv:
        _verbose = True
        levels['output'].append('debug')
    if "--debug" in sys.argv:
        _debug = True
        _verbose = True
        levels['output'].append('debug')
    for param in sys.argv:
        if param.startswith('--updated='):
            updated = param[11:].split(',')
            if 'self' in updated:
                _self_updated = True
            if 'script' in updated:
                _script_updated = True
            if 'dockerfile' in updated:
                _dockerfile_updated = True
            if 'examplefiles' in updated:
                _examplefiles_updated = True

    # choose command
    _command = 'update'
    for i, param in enumerate(sys.argv):
        if param == "--help":
            _command = 'help'
            break
        if param == "--diff":
            _command = 'diff'
            break
        if param == "--status":
            _command = 'status'
            break
        if param == "--pull":
            _command = 'pull'
            break
        if param == "--push":
            _command = 'push'
            break
        if param == "--commit":
            _command = 'commit'
            if len(sys.argv) < i + 2:
                sys.exit("No commit message")
            _commit_msg = sys.argv[i + 1]

    # print help
    if _command == 'help':
        print(__doc__.strip())
        sys.exit(2)

    # set workdir
    os.chdir(root)

    # execute command
    if _command not in _commands:
        sys.exit("command `%s` not found" % _command)
    getattr(sys.modules[__name__], _command)()
