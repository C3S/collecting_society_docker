#!/usr/bin/env python3
# For copyright and license terms, see COPYRIGHT.rst (top level of repository)
# Repository: https://github.com/C3S/collecting_society_docker
"""
Usage: ./scripts/update [--reset] [--diff] [--help]

  This script updates the project:
    - Creation of files and folders
    - Copy of FILE.example files to FILE
    - Checkout/Pull of the source repositories (including this one)
    - Checkout/Pull of the reference repositories

Options:
  --reset: overrides the configuration files with .example
  --diff: just outputs the diff of .example files, performs no other updates
"""

import os
import sys
import shutil
import traceback
import subprocess
import pprint
from subprocess import STDOUT as stdout
from pathlib import Path
import difflib
import re
import yaml
from collections.abc import Mapping
from collections import OrderedDict
from copy import deepcopy

# regex
envre = re.compile(r'''^([^\s=]+)=(?:[\s"']*)(.+?)(?:[\s"']*)$''')
envsubre = re.compile(r'\$\{([A-Z-_]*)\}')

# flags
_verbose = False
_debug = False
_reset = False
_self_updated = False
_script_updated = False
_dockerfile_updated = False
_examplefiles_updated = False

# stacks
_contexts = []   # list of contexts
_messages = []   # list of messages added
_tasks = []      # stack of tasks performed

# registers
_command = None  # the initially invoked command
_commands = []   # list of valid command names, autofilled
_actions = []    # list of valid action names, autofilled


# --- tools -------------------------------------------------------------------

def get_root_dir():
    """Returns the root directory of the project."""
    root = os.path.realpath(
        os.path.join(os.path.abspath(__file__), "..", ".."))
    assert os.path.exists(os.path.join(root, '.git'))
    return root


def get_repo_name(path="."):
    """Returns the repository name of the project."""
    return os.path.basename(os.path.abspath(path))


def get_repo_branch(path="."):
    return subprocess.check_output(
        ('git', 'rev-parse', '--abbrev-ref', 'HEAD'),
        stderr=subprocess.STDOUT).rstrip().decode('utf-8')


def replace_env_vars(dictionary, env):
    """Substitues placeholders in dictionary with environment variables."""
    for key, val in dictionary.items():
        if isinstance(val, Mapping):
            replace_env_vars(val, env)
        elif isinstance(val, list):
            for i, item in enumerate(val):
                if isinstance(item, str):
                    for (match) in envsubre.findall(item):
                        dictionary[key][i] = dictionary[key][i].replace(
                            '${%s}' % match, env[match])
                    continue
                replace_env_vars(item, env)
        elif isinstance(val, str):
            for (match) in envsubre.findall(val):
                dictionary[key] = dictionary[key].replace(
                    '${%s}' % match, env[match])
    return dictionary


def get_dot_env(path="."):
    """Reads the shared environment file and parses it into a dictionary."""
    path = os.path.join(path, ".env")
    if not os.path.isfile(path):
        path += '.example'
    assert os.path.isfile(path)
    env = {}
    with open(path) as _file:
        for line in _file:
            match = envre.match(line)
            if match is not None:
                env[match.group(1)] = match.group(2)
    return replace_env_vars(env, env)


def get_project_yaml(path=".", env={}):
    """Reads the project yaml file and parses it into a dictionary."""
    with open(os.path.join(path, "project.yml"), 'r') as _file:
        # load yaml file
        project = yaml.safe_load(_file)
        # replace env vars
        replace_env_vars(project, env)
        # inherit configurations
        project['staging'] = merge_dicts(
            deepcopy(project['production']), project['staging'])
        project['testing'] = merge_dicts(
            deepcopy(project['staging']), project['testing'])
        project['development'] = merge_dicts(
            deepcopy(project['testing']), project['development'])
        # preprocess tasks
        for _e, environment in project.items():
            if not environment or not environment.get('tasks'):
                continue
            for _c, command in environment['tasks'].items():
                if not command:
                    continue
                for task in command:
                    # ensure task name
                    assert task.get('name'), (
                        "task has no name.\n\n"
                        "yaml: %s/tasks/%s\n"
                        "task: %s" % (_e, _c, task))
                    # ensure task actions are a list
                    actions = task.get('actions', [])
                    if isinstance(actions, str):
                        task['actions'] = [actions]
                    # substitue task groups
                    groups = environment.get('actions')
                    if groups:
                        actions = []
                        for action in task['actions']:
                            islist = isinstance(groups.get(action), list)
                            if action in groups and islist:
                                actions += groups[action]
                                continue
                            actions.append(action)
                        task['actions'] = actions
                    # ensure task actions are valid and attributes are set
                    for action in task['actions']:
                        assert action in actions, (
                            "action `%s` of task with name `%s` not found.\n\n"
                            "yaml: %s/tasks/%s\n"
                            "task: %s" % (action, task['name'], _e, _c, task))
    return project


def merge_dicts(orig_dict, new_dict):
    """
    Recursively merges dict-like objects.

    Note:
        If a value in new_dict is `{}`, the key is removed in orig_dict.
        Lists of dicts
        - are merged with key 'name' as identifier.
        - can be inserted with the key 'before'/'after' and value name.

    Args:
        orig_dict (dict): Original dictionary to be merged with.
        new_dict (dict): New dictionary to be merged.

    Returns:
        dict: Merged dict.

    Examples:
        >>> orig_dict = {
        ...     'A': {
        ...         'A1': 'A1',
        ...         'A2': 'A2'
        ...     },
        ...     'B': 'B'
        ...     'C': [
        ...         {'name': 'one', 'item': 'old'},
        ...         {'name': 'three'},
        ...     ]
        ... }
        >>> new_dict = {
        ...     'A': {
        ...         'A2': 'XX'
        ...     },
        ...     'B': {},
        ...     'C': [
        ...         {'name': 'one', 'item': 'new'},
        ...         {'name': 'two', 'after': 'one'},
        ...     'D': 'D'
        ... }
        >>> print(cls.merge_dicts(orig_dict, new_dict))
        {
            'A': {
                'A1': 'A1',
                'A2': 'XX'
            },
            'C': [
                {'name': 'one', 'item': 'new'},
                {'name': 'two'},
                {'name': 'three'},
            ],
            'D': 'D',
        }
    """
    if not new_dict:
        return isinstance(new_dict, Mapping) and new_dict or orig_dict
    for key, val in new_dict.items():
        # delete key if val == {}
        if isinstance(val, Mapping) and not val:
            orig_dict.pop(key, None)
        # update with OrderedDict
        if isinstance(val, OrderedDict):
            r = merge_dicts(OrderedDict(orig_dict.get(key, {})), val)
            orig_dict[key] = r
        # update with Mapping
        elif isinstance(val, Mapping):
            r = merge_dicts(orig_dict.get(key, {}), val)
            orig_dict[key] = r
        # update with Lists of items having all the key 'name'
        elif isinstance(val, list) and \
                sum(['name' in v for v in val]) == len(val):
            for new_item in val:
                new = True
                for i, orig_item in enumerate(orig_dict[key]):
                    if new_item['name'] == orig_item['name']:
                        new = False
                        orig_dict[key][i] = merge_dicts(orig_item, new_item)
                if new:
                    insert = ''
                    if 'after' in new_item:
                        insert = 'after'
                    if 'before' in new_item:
                        insert = 'before'
                    if insert:
                        for i, orig_item in enumerate(orig_dict[key]):
                            if new_item[insert] == orig_item['name']:
                                break
                        if insert == 'after':
                            i += 1
                        new_item.pop('after', None)
                        new_item.pop('before', None)
                        orig_dict[key].insert(i, new_item)
                    else:
                        orig_dict[key].append(new_item)
        # update with other objects
        elif isinstance(orig_dict, Mapping):
            orig_dict[key] = new_dict[key]
        else:
            orig_dict = {key: new_dict[key]}
    return orig_dict


# --- templates ---------------------------------------------------------------

def color(text, status):
    """Colored output wrapper for stdout text."""
    text = str(text)
    if isinstance(status, str):
        status = [status]
    # start
    for s in status:
        s = s.lower()
        if s.startswith("\033"):
            text = s + text
        if s in colors:
            text = color(text, colors[s])
    # stop
    if text.startswith("\033") and not text.endswith("[0m"):
        text += "\033[0m"
    return text


def message(msg, offset=1, pad=10, data=True, add=True, output=True):
    """Prints a message."""
    # default
    default = {'level': "debug"}
    if _tasks:
        default['action'] = _tasks[-1]['action'].replace("_", " ")
        default['title'] = _tasks[-1]['name']
    msg = {**default, **msg}
    # color
    _color = msg.get("level", "dim")
    # level
    text = "  " * offset
    level = (msg['level'] + " | ").rjust(pad)
    text += color(level, _color + "_level")
    # title
    if 'title' in msg:
        title = msg['title']
        if title == ".":
            title = repo
        text += color(title, _color + "_title") + " "
    # action
    if 'action' in msg:
        action = msg['action'] + " ... "
        if msg['level'] == "error":
            action = msg['action']
        if 'description' in msg:
            action = msg['action'] + " Â» "
        text += color(action, _color + "_action")
    # description
    if 'description' in msg:
        if msg['level'] == 'error':
            _color = 'info'
        text += color(msg["description"], [_color + "_description", 'italic'])
    # data
    if data and 'data' in msg and msg['data']:
        raw = msg['data']
        if isinstance(raw, (bytes, bytearray)):
            raw = raw.strip().decode('utf-8')
        lines = raw
        if isinstance(raw, str):
            lines = raw.rstrip().split("\n")
        data = ""
        for line in lines:
            data += "\n" + "  " * offset + " ".ljust(pad) + line
        data += "\n"
        text += color(data, _color + "_data")
    text += "\n"
    # process
    if add:
        _messages.append(msg)
    if output and msg['level'] in levels['output']:
        print(text, end="")
    return text


def line(length=89, _color="title", end="\n", output=True):
    """Prints a division line."""
    text = color("-" * length, _color)
    # process
    if output:
        print(text, end=end)
    return text


def header(output=True):
    """Prints the project configuration header."""
    # data
    data = {
        "project": env.get('PROJECT'),
        "environment": environment,
        "branch": branch,
        "root": root,
    }
    if username and useremail:
        data['user'] = "%s <%s>" % (username, useremail)
    else:
        global_username = execute(
            ('git', 'config', '--global', 'user.name'), log=False)
        global_useremail = execute(
            ('git', 'config', '--global', 'user.name'), log=False)
        data['user'] = "%s <%s>" % (global_username, global_useremail)
        message({'level': "info",
                 'description': "GIT_USER_NAME/EMAIL in .env not set",
                 'data': "NOTE: commits will use: %s" % data['user']})
    # text
    pad = 0
    for key in data:
        if len(key) > pad:
            pad = len(key)
    pad += 1
    text = "\n"
    for key, value in data.items():
        value_color = 'dim'
        if key in ['environment', 'branch'] and value not in environments:
            value_color = 'warning'
        text += (
            color("  " + key.capitalize().ljust(pad), 'title') +
            color(value + "\n", value_color)
        )
    separator = line(output=False)
    text = "\n" + separator + "\n" + text + "\n" + separator + "\n"
    # process
    if output:
        print(text, end="")
    return text


def title(string, _color="subtitle", output=True):
    """Prints a formatted title."""
    text = "\n" + color("> ", 'title') + color(string, _color) + "\n\n"
    # process
    if output:
        print(text, end="")
    return text


def footer(string="Success.", _color="success", output=True, summary=True):
    """Prints the result of the command and a summary of important messages."""
    # determine what to output
    had_output = False
    has_summary = False
    for msg in _messages:
        if msg['level'] in levels['output']:
            had_output = True
        if msg['level'] in levels['summary']:
            has_summary = True
    if not had_output:
        print(color("   All fine.", 'dim'))
    # separator
    text = "\n" + line(output=False) + "\n\n"
    # summary
    text += title("Summary", _color='title', output=False)
    # data
    data = {
        "environment": environment,
        "branch": branch,
    }
    text += "  "
    for key, value in data.items():
        value_color = 'dim'
        if key in ['environment', 'branch'] and value not in environments:
            value_color = 'warning'
        text += (
            color(key.capitalize(), ['dim', 'bold']) + " " +
            color(value, value_color) + ", "
        )
    text = text[:-2] + "\n"
    # messages
    if summary and has_summary:
        text += "\n"
        data = False
        for level in levels['summary']:
            if level == 'ERROR':
                data = True
            for msg in [m for m in _messages if m['level'] == level]:
                text += message(msg, data=data, add=False, output=False)
    # title
    text += title(string, _color=_color, output=False)
    # process
    if output:
        print(text, end="")
    return text


def debug(obj=None, title=""):
    """Prints objects for debugging."""
    if not _debug:
        return
    pad = 12
    # title
    if title:
        print(" " * pad + color(title, ['output', 'bold']))
    # object
    if not isinstance(obj, str):
        obj = pprint.pformat(obj)
    for line in obj.split("\n"):
        print(" " * pad + color(line, 'output'))
    print()


def error(msg):
    """Prints an error."""
    _msg = {
        'level': "error",
    }
    if _tasks:
        _msg['title'] = "%s: `%s`" % (
            _tasks[-1]['action'].replace("_", " "), _tasks[-1]['name'])
    message({**_msg, **msg})
    footer("Aborted.", _color="info", summary=False)
    sys.exit(-1)


# --- execution ---------------------------------------------------------------

def execute(cmd, cwd=False, abort=True, stop=False, msg={}, log=True):
    """Executes a command via subprocess check_output."""
    # print hint for the operation
    context = get_context()
    task = None
    action = "command"
    title = " ".join(cmd)
    if _tasks:
        task = _tasks[-1]
        action = task['action'].replace("_", " ") or "command"
        title = task['name'] or " ".join(cmd)
    if log:
        message({'action': action, 'title': title}, add=False)
    output = ""
    error_msg = {}
    # execute command
    try:
        output = subprocess.check_output(
            cmd, cwd=cwd or root, stderr=stdout
        ).rstrip().decode('utf-8')
        if _debug:
            debug(output, "$ " + " ".join(cmd))
    except subprocess.CalledProcessError as err:
        error_msg = {
            'title': "$ " + cmd[0],
            'action': len(cmd) > 1 and " ".join(cmd[1:]) or "",
            'data': err.output,
        }
        if abort:
            error(error_msg)
    # stop task
    if task and stop:
        stopped = output
        if callable(stop):
            stopped = stop(output)
        context['task']['stopped'] = stopped
    # return if logging is disabled for this command
    if not log:
        return output
    # create message
    _msg = {
        'level': output and "warning" or "info",
        'action': action,
        'title': title,
        'description': output and "not ok" or "ok",
        'data': output and "$ " + " ".join(cmd) + "\n" + output,
    }
    msg = {**_msg, **msg, **error_msg}
    # execute callback functions for messages dependent on the output
    for key, value in msg.items():
        if callable(value):
            msg[key] = value(output)
    # remove hin, add and print message
    if 'debug' in levels['output']:
        sys.stdout.write("\033[F")
    message(msg)
    # add output to task
    if _tasks:
        task = _tasks[-1]
        if 'output' not in task:
            task['output'] = {}
        task['output'][task['action']] = output
    return output


# --- actions -----------------------------------------------------------------

def action(func):
    """Action decorator, registers available functions, skips stopped tasks."""
    current_action = func.__name__
    _actions.append(current_action)

    def wrapper(task, context={}, *args, **kwargs):
        # stop to process actions of stopped tasks
        if task.get('stopped'):
            return
        # add action config
        actions_config = project[environment]['actions']
        context['actions'] = actions_config.get(current_action)
        # apply the action
        try:
            func(task, context, *args, **kwargs)
        except Exception:
            error({'data': traceback.format_exc()})
    return wrapper


@action
def link_path(task, context={}):
    """Symlinks a file or folder."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # source path does not exist
    if not os.path.exists(source):
        error({'description': "source path not found",
               'data': "source: %s" % task['source']})

    # new symlink, file does not exist
    source_rel = os.path.relpath(source, os.path.dirname(target))
    if not os.path.exists(target):
        os.symlink(source_rel, target)
        message({'level': "info", 'description': "symlink created"})
        return

    # file exists, but is no symlink
    if not os.path.islink(target):
        error({'description': "target exists and is not a link"})

    # symlink exists and points already to source
    old_source = os.readlink(target)
    if source_rel == old_source:
        message({'description': "symlink exists"})
        return

    # symlink exists, but is changed
    os.unlink(target)
    os.symlink(source_rel, target)
    message({'level': "warning", 'description': "symlink overwritten",
             'data': "\n".join(["old source: `%s`" % old_source,
                                "new source: `%s`" % source_rel])})


@action
def create_file(task, context={}):
    """Creates a file."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    target = os.path.join(root, target)
    target_folder = os.path.dirname(target)

    # folder of file does not exist
    if not os.path.isdir(target_folder):
        error({'description': "folder does not exist", 'data': target_folder})

    # file already exists
    if os.path.exists(target):
        message({'description': "file exists"})
        return

    # new file created
    Path(target).touch()
    message({'level': "info", 'description': "file created"})


@action
def copy_file(task, context={}):
    """Copies a file."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    source = task.get('source')
    if not source:
        source = target + ".example"
    target = os.path.join(root, target)
    source = os.path.join(root, source)

    # source file to copy not found
    if not os.path.exists(source):
        error({'description': "source file not found"})

    # file already exists
    target_exists = os.path.exists(target)
    if target_exists and not _reset:
        message({'description': "file_exists"})
        return

    # file overwritten due to reset switch
    if target_exists and _reset:
        shutil.copyfile(source, target)
        message({'level': "warning", 'description': "file overwritten"})
        return

    # new file copied
    shutil.copyfile(source, target)
    message({'level': "info", 'description': "file copied"})


@action
def diff_file(task, context={}):
    """Diffs example files, prints output and returns different filenames."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    source = task.get('source')
    if not source:
        source = target + ".example"
    target = os.path.join(root, target)
    source = os.path.join(root, source)

    # source or target not found
    if not os.path.exists(source):
        error({'description': "source path not found"})
    if not os.path.exists(target):
        error({'description': "target path not found"})

    # create diff
    with open(source, 'r') as source_file, open(target, 'r') as target_file:

        # get diff
        source_content = source_file.readlines()
        target_content = target_file.readlines()
        diff = difflib.unified_diff(
            source_content, target_content,
            fromfile=os.path.basename(source), tofile=task["name"])
        try:
            line = next(diff)
        except StopIteration:
            message({'description': 'file is identical'})
            return
        lines = [line] + [d for d in diff]

        # filter diff
        ignorere = context['actions']['ignore']
        if isinstance(ignorere, list):
            ignorere = re.compile(r'(%s)' % "|".join(ignorere))
            context['actions']['ignore'] = ignorere
        ignored = False
        filtered = []
        for line in lines[2:]:
            if not line[0] in ["+", "-"]:
                continue
            match = ignorere.match(line[1:])
            if match is not None:
                ignored = True
                continue
            filtered.append(line)

        # files are identical
        if not filtered:
            message({'level': 'info',
                     'description': 'file contain only ignored differences'})
            return

        # files have differences
        data = colors['clear']
        if ignored:
            data += color("--8<-- (ignored lines stripped) --8<--", "dim")
            data += colors['clear'] + "\n"
        for line in lines[0:3] + filtered:
            if line.startswith('-'):
                data += colors['remove']
            if line.startswith('+'):
                data += colors['add']
            if line.startswith('@'):
                data += colors['hunk']
            data += line
        data = data.rstrip() + colors['clear']
        level = "warning"
        description = "differences found"
        if _examplefiles_updated:
            level = "error"
            description += " (examplefiles changed!)"
        message({'level': level, 'description': description,
                 'data': data})


@action
def create_folder(task, context={}):
    """Creates a folder."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    target = os.path.join(root, target)

    # folder already exists
    if os.path.exists(target):
        message({'description': "folder exists"})
        return

    # new folder created
    os.makedirs(target)
    message({'level': "info", 'description': "folder created"})


@action
def copy_folder(task, context={}):
    """Copies a folder."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # folder already exists
    if os.path.exists(target) and not _reset:
        message({'description': "folder exists"})
        return

    # folder overwritten due to reset switch
    shutil.copytree(source, target)
    if _reset:
        shutil.copytree(source, target)
        message({'level': "info", 'description': "folder copied"})
        return

    # new folder copied
    shutil.copytree(source, target)
    message({'level': "warning", 'description': "folder overwritten"})


@action
def clone_repo(task, context={}):
    """Clones a repository."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    if context['actions']['create_folder']:
        create_folder({'name': os.path.dirname(target)})

    # choose ssh or https
    if "@" in source and not (username and useremail):
        url = source.split("@", 1)[1]
        source = "https://" + url.replace(":", "/")

    # repo already exists
    if os.path.exists(os.path.join(target, '.git')):
        message({'description': "repo exists"})
        return

    # new repo cloned
    execute(('git', 'clone', '--quiet', source, target))


@action
def set_origin(task, context={}):
    """Sets the origin of a repository."""
    source = task['source']
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # choose ssh or https
    if "@" in source and not (username and useremail):
        url = source.split("@", 1)[1]
        source = "https://" + url.replace(":", "/")

    # origin already set
    old_source = execute(
        ('git', 'remote', 'get-url', 'origin'), cwd=target, log=False)
    if source == old_source:
        message({'description': "origin already set"})
        return

    # origin changed
    msg = {
        'level': "warning",
        'description': "origin changed",
        'data': "\n".join([
            "old origin: `%s`" % old_source,
            "new origin: `%s`" % source])}
    execute(('git', 'remote', 'set-url', 'origin', source),
            cwd=target, msg=msg)


@action
def set_user(task, context={}):
    """Sets the username and useremail of a repository."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)

    # skip silently for upstream repos
    if upstream:
        return

    # skip silently, if userdata is not set
    if not username or not useremail:
        return

    # userdata already set
    old_username = execute(
        ('git', 'config', 'user.name'), cwd=target, log=False).strip('"')
    old_useremail = execute(
        ('git', 'config', 'user.email'), cwd=target, log=False).strip('"')
    if username == old_username and old_useremail == old_useremail:
        message({'description': "git user aready set"})
        return

    # userdata set
    execute(('git', 'config', 'user.name', '"{}"'.format(username)),
            cwd=target, log=False)
    execute(('git', 'config', 'user.email', '"{}"'.format(useremail)),
            cwd=target, log=False)
    message({'level': "info", 'description': "git user set",
             'data': "\n".join(["user.name: `%s`" % username,
                                "user.email: `%s`" % useremail])})


@action
def check_status(task, context={}):
    """Checks the status of the repository, cancels task if not ok."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    upstream = task.get('upstream', True)

    # workdir checked
    msg = {'level': lambda o: o and "warning" or "debug",
           'description':
               lambda o: o and "workdir not clean -> update skipped" or "ok"}
    cmd = ['git', 'status', '--porcelain']
    if upstream:
        cmd.append('--untracked-files=no')
    execute(cmd, cwd=target, stop=True, msg=msg)


@action
def fetch_repo(task, context={}):
    """Fetches updates for a repository."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)

    # new updates fetched
    msg = {'level': lambda o: o and "info" or "debug",
           'description': lambda o: o and "updates available" or "uptodate"}
    execute(('git', 'fetch'), cwd=target, msg=msg)


@action
def checkout_repo(task, context={}):
    """Checksout a branch or tag in a repository."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']
    upstream = task.get('upstream', True)

    # get checked out version
    old_version = execute(
        ('git', 'rev-parse', '--abbrev-ref', 'HEAD'), cwd=target, log=False)
    if old_version == "HEAD":
        old_version = execute(
            ('git', 'name-rev', '--name-only', 'HEAD'), cwd=target, log=False)
    if old_version.endswith("^0"):
        old_version = old_version[:-2]
    checked_out = old_version == version and True or False

    # find out, if branch or tag exists locally
    version_exists = False
    if version.startswith("tags/"):
        output = execute(
            ('git', 'tag', '-l', version[5:]), cwd=target, log=False)
        if output:
            version_exists = True
    else:
        output = execute(('git', 'branch', '-lvv'), cwd=target, log=False)
        for line in output.split("\n"):
            if line[2:].startswith(version + " "):
                version_exists = True

    # just checkout, if remote or local branch exists
    if version_exists:

        # version already checked out
        if checked_out:
            message({'description': "already on `%s`" % version})
            return

        # version switched
        msg = {'level': "info", 'description': "branch switched",
               'data': "\n".join(["old branch/tag: `%s`" % old_version,
                                  "new branch/tag: `%s`" % version])}
        execute(('git', 'checkout', '--quiet', version),
                cwd=target, msg=msg)
        return

    # upstream version does not exist
    if upstream or version.startswith("tags/"):
        error({'description': "no upstream version `%s` found" % version})

    # new branch created
    msg = {'level': 'info', 'description': "new branch created",
           'data': 'branch name: `%s`' % version}
    execute(('git', 'checkout', '-b', version), cwd=target, msg=msg)


@action
def track_remote(task, context={}):
    """Ensures, that remote branches are followed."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']
    upstream = task.get('upstream', True)

    # skip silently for upstream repos and tags
    if upstream or version.startswith("tags/"):
        return

    # find out, if remote branch exists
    remote_exists = False
    output = execute(('git', 'branch', '-rvv'), cwd=target, log=False)
    for line in output.split("\n"):
        if line[2:].startswith("origin/%s " % version):
            remote_exists = True

    # skip, if remote brach does not exist
    if not remote_exists:
        message({'description':
                 'upstream branch `%s` does not exist' % version})
        return

    # get currently tracked branch
    tracked_branch = execute(
        ('git', 'rev-parse', '--abbrev-ref',
         '--symbolic-full-name', '@{u}'),
        cwd=target, abort=False, log=False)
    is_tracked = tracked_branch == "origin/%s" % version

    # remote branch is already tracked
    if is_tracked:
        message({'description':
                 'upstream branch `%s` already tracked' % version})
        return

    # track remote branch
    # NOTE: conflicts, if the same branch was created and committed to on
    # different repositories. this edge case should be rare.
    msg = {'level': "info",
           'description':
               "switched upstream branch from `%s` to `%s`" % (
                   tracked_branch, "origin/%s" % version)}
    execute(('git', 'branch', '-u', 'origin/%s' % version, version),
            cwd=target, msg=msg)


@action
def pull_repo(task, context={}):
    """Pulls updates in a repository branch."""
    target = task.get('target') or task['name']
    targetpath = task.get('targetpath')
    if targetpath:
        target = os.path.join(targetpath, target)
    version = task['version']

    # skip pull silently for tags
    if task['version'].startswith("tags/"):
        return

    # skip pull for local only branches
    tracked_branch = execute(
        ('git', 'rev-parse', '--abbrev-ref',
         '--symbolic-full-name', '@{u}'),
        cwd=target, abort=False, log=False)
    is_local = not tracked_branch.startswith("origin/%s" % version)
    if is_local:
        message({'description': "no remote branch `%s` -> pull skipped"
                 % version})
        return

    # pull performed
    msg = {'level': lambda o: 'changed' in o and "info" or "debug",
           'description': lambda o: 'changed' in o and "updated" or "uptodate",
           'data': lambda o: 'changed' in o and o or ""}
    execute(('git', 'pull'), cwd=target, msg=msg)


@action
def restart_script(task, context={}):
    """Restarts the update script after updated of itself was checkedout."""
    # target = task['name']
    # updated = ['self']
    # if pull_result:
    #     if 'scripts/update |' in pull_result:
    #         updated.append('script')
    #     if 'services/build/Dockerfile |' in pull_result:
    #         updated.append('dockerfile')
    #     if '.example |' in pull_result:
    #         updated.append('examplefiles')
    pass


# --- tasks -------------------------------------------------------------------

def get_context():
    """Returns the current context."""
    if _contexts:
        return _contexts[-1]
    return


def set_context(override={}):
    """Sets the context for a command, adds it to the stack."""
    current_env = project[environment]
    current_cmd = override.get('command', _command)
    # default context
    context = {
        # command config
        'commands': current_env['commands'].get(current_cmd),
        # current command
        'command': current_cmd,
        # task config
        'tasks': deepcopy(current_env['tasks'].get(current_cmd)),
        # current task
        'task': None,
        # action config
        'actions': {},
        # current action
        'action': None,
    }
    # overrides
    context.update(override)
    # add context
    _contexts.append(context)
    return context


def process(context):
    """Main loop to process tasks."""
    # no tasks
    if not context['tasks']:
        error({'title': "No tasks"})
    # process tasks
    for task in context['tasks']:
        # batch tasks
        if task.get('batch'):
            batchtasks = []
            for batchtask in task['batch']:
                batchtasks.append({**task, **batchtask, **{'batch': False}})
            batch = set_context(
                {'command': context['command'], 'tasks': batchtasks})
            process(batch)
        # single tasks
        else:
            context['task'] = task
            for action in task['actions']:
                context['action'] = action
                _tasks.append({**task, **{'action': action}})
                if action in _actions:
                    getattr(sys.modules[__name__], action)(task, context)
    _contexts.pop()


# --- commands ----------------------------------------------------------------

def command(func):
    """Command decorator, handles context and wrap switch."""
    current_command = func.__name__
    _commands.append(current_command)

    def wrapper(*args, **kwargs):
        # set new command context
        context = set_context({'command': _command})
        # apply filters
        try:
            func(*args, **kwargs)
        except Exception:
            error({'data': traceback.format_exc()})
        # print header (only once)
        if current_command == _command:
            header()
        # print title
        title(_command.capitalize() + " ...")
        # process tasks
        process(context)
        # print footer (only once)
        if current_command == _command:
            footer()
    return wrapper


@command
def diff():
    """Prints the diffs of the example files."""
    # filter tasks with action diff_file
    context = get_context()
    tasks = []
    for task in context['tasks']:
        if 'diff_file' not in task['actions']:
            continue
        task['actions'] = ['diff_file']
        tasks.append(task)
    context['tasks'] = tasks


@command
def update():
    """Updates itself and the repositories, creates folders, copies files."""
    pass


# --- configuration -----------------------------------------------------------

# project
root = get_root_dir()
repo = get_repo_name(root)
env = get_dot_env(root)
project = get_project_yaml(root, env)
environments = project.keys()

# environment
environment = env['ENVIRONMENT']
branch = env['BRANCH']
username = env.get('GIT_USER_NAME')
useremail = env.get('GIT_USER_EMAIL')

# messages
levels = {
    'output':  ['error', 'warning', 'info'],
    'summary': ['error', 'warning']
}
colors = {
    # level
    'error': "\033[91m",
    'error_level': 'error',
    'error_title': ['title', 'bold'],
    'error_action': '',
    'error_description': ['error', 'bold'],
    'error_data': 'dim',
    'warning': "\033[33m",
    'warning_level': 'warning',
    'warning_title': ['warning', 'bold'],
    'warning_action': '',
    'warning_description': 'warning',
    'warning_data': 'dim',
    'info': '',
    'info_level': 'info',
    'info_title': ['info', 'bold'],
    'info_action': 'info',
    'info_description': 'dim',
    'info_data': 'dim',
    'debug': "\033[2m",
    'debug_level': 'debug',
    'debug_title': ['debug', 'bold'],
    'debug_action': 'dim',
    'debug_description': 'debug',
    'debug_data': 'dim',
    # context
    'title': ['bold', "\033[33m"],
    'subtitle': "\033[35m",
    'output': "\033[94m",
    'success': "\033[32m",
    # diff
    'hunk': "\033[36m",
    'remove': "\033[31m",
    'add': "\033[32m",
    # function
    'clear': "\033[0m",
    'bold': "\033[1m",
    'dim': "\033[2m",
    'italic': "\033[3m",
    'underline': "\033[4m",
    'blink': "\033[5m",
}


# --- entrypoint --------------------------------------------------------------

if __name__ == "__main__":

    # set flags
    if "--reset" in sys.argv:
        _reset = True
    if "--verbose" in sys.argv:
        _verbose = True
        levels['output'].append('debug')
    if "--debug" in sys.argv:
        _debug = True
        _verbose = True
        levels['output'].append('debug')
    for param in sys.argv:
        if param.startswith('--updated='):
            updated = param[11:].split(',')
            if 'self' in updated:
                _self_updated = True
            if 'script' in updated:
                _script_updated = True
            if 'dockerfile' in updated:
                _dockerfile_updated = True
            if 'examplefiles' in updated:
                _examplefiles_updated = True

    # choose command
    _command = 'update'
    if "--diff" in sys.argv:
        _command = 'diff'
    if "--help" in sys.argv:
        _command = 'help'

    # print help
    if _command == 'help':
        print(__doc__.strip())
        sys.exit(2)

    # set workdir
    os.chdir(root)

    # execute command
    if _command == 'update':
        update()
    if _command == 'diff':
        diff()
